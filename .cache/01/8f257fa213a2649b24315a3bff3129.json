{"id":"node_modules/sentence-splitter/lib/parser/SourceCode.js","dependencies":[{"name":"/Users/tom/Documents/GitHub/fabricating-alternatives-004/node_modules/sentence-splitter/lib/parser/SourceCode.js.map","includedInParent":true,"mtime":499162500000},{"name":"/Users/tom/Documents/GitHub/fabricating-alternatives-004/node_modules/sentence-splitter/src/parser/SourceCode.ts","includedInParent":true,"mtime":499162500000},{"name":"/Users/tom/Documents/GitHub/fabricating-alternatives-004/package.json","includedInParent":true,"mtime":1563189193141},{"name":"/Users/tom/Documents/GitHub/fabricating-alternatives-004/node_modules/sentence-splitter/package.json","includedInParent":true,"mtime":1563189192585},{"name":"structured-source","loc":{"line":3,"column":30},"parent":"/Users/tom/Documents/GitHub/fabricating-alternatives-004/node_modules/sentence-splitter/lib/parser/SourceCode.js","resolved":"/Users/tom/Documents/GitHub/fabricating-alternatives-004/node_modules/structured-source/lib/index.js"}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar StructureSource = require(\"structured-source\");\nvar SourceCode = /** @class */ (function () {\n    function SourceCode(input) {\n        this.index = 0;\n        this.contexts = [];\n        this.contextRanges = [];\n        if (typeof input === \"string\") {\n            this.textCharacters = input.split(\"\");\n            this.source = new StructureSource(input);\n            this.startOffset = 0;\n            this.firstChildPadding = 0;\n        }\n        else {\n            this.sourceNode = input;\n            // When pass AST, fist node may be >=\n            // Preserve it as `startOffset`\n            this.startOffset = this.sourceNode.range[0];\n            // start index is startOffset\n            this.index = this.startOffset;\n            // before line count of Paragraph node\n            var lineBreaks = Array.from(new Array(this.sourceNode.loc.start.line - 1)).fill(\"\\n\");\n            // filled with dummy text\n            var offset = Array.from(new Array(this.startOffset - lineBreaks.length)).fill(\"∯\");\n            this.textCharacters = offset.concat(lineBreaks, input.raw.split(\"\"));\n            this.source = new StructureSource(this.textCharacters.join(\"\"));\n            if (this.sourceNode.children[0]) {\n                // Header Node's children does not start with index 0\n                // Example: # Header\n                // It firstChildPadding is `2`\n                this.firstChildPadding = this.sourceNode.children[0].range[0] - this.startOffset;\n            }\n            else {\n                this.firstChildPadding = 0;\n            }\n        }\n    }\n    SourceCode.prototype.markContextRange = function (range) {\n        this.contextRanges.push(range);\n    };\n    SourceCode.prototype.isInContextRange = function () {\n        var offset = this.offset;\n        return this.contextRanges.some(function (range) {\n            return range[0] <= offset && offset < range[1];\n        });\n    };\n    SourceCode.prototype.enterContext = function (context) {\n        this.contexts.push(context);\n    };\n    SourceCode.prototype.isInContext = function (context) {\n        if (!context) {\n            return this.contexts.length > 0;\n        }\n        return this.contexts.some(function (targetContext) { return targetContext === context; });\n    };\n    SourceCode.prototype.leaveContext = function (context) {\n        var index = this.contexts.lastIndexOf(context);\n        if (index !== -1) {\n            this.contexts.splice(index, 1);\n        }\n    };\n    Object.defineProperty(SourceCode.prototype, \"offset\", {\n        /**\n         * Return current offset value\n         * @returns {number}\n         */\n        get: function () {\n            return this.index + this.firstChildPadding;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Return current position object.\n     * It includes line, column, offset.\n     */\n    SourceCode.prototype.now = function () {\n        var indexWithChildrenOffset = this.offset;\n        var position = this.source.indexToPosition(indexWithChildrenOffset);\n        return {\n            line: position.line,\n            column: position.column,\n            offset: indexWithChildrenOffset\n        };\n    };\n    Object.defineProperty(SourceCode.prototype, \"hasEnd\", {\n        /**\n         * Return true, no more read char\n         */\n        get: function () {\n            return this.read() === false;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * read char\n     * if can not read, return empty string\n     * @returns {string}\n     */\n    SourceCode.prototype.read = function (over) {\n        if (over === void 0) { over = 0; }\n        var index = this.offset + over;\n        if (index < this.startOffset) {\n            return false;\n        }\n        if (0 <= index && index < this.textCharacters.length) {\n            return this.textCharacters[index];\n        }\n        return false;\n    };\n    /**\n     * read node\n     * if can not read, return empty string\n     * @returns {node}\n     */\n    SourceCode.prototype.readNode = function (over) {\n        if (over === void 0) { over = 0; }\n        if (!this.sourceNode) {\n            return false;\n        }\n        var index = this.offset + over;\n        if (index < this.startOffset) {\n            return false;\n        }\n        var matchNodeList = this.sourceNode.children.filter(function (node) {\n            // <p>[node]</p>\n            //         ^\n            //        range[1]\n            // `< range[1]` prevent infinity loop\n            // https://github.com/azu/sentence-splitter/issues/9\n            return node.range[0] <= index && index < node.range[1];\n        });\n        if (matchNodeList.length > 0) {\n            // last match\n            // because, range is overlap two nodes\n            return matchNodeList[matchNodeList.length - 1];\n        }\n        return false;\n    };\n    /**\n     * Increment current index\n     */\n    SourceCode.prototype.peek = function () {\n        this.index += 1;\n    };\n    /**\n     * Increment node range\n     */\n    SourceCode.prototype.peekNode = function (node) {\n        this.index += node.range[1] - node.range[0];\n    };\n    /**\n     * Seek and Peek\n     */\n    SourceCode.prototype.seekNext = function (parser) {\n        var startPosition = this.now();\n        parser.seek(this);\n        var endPosition = this.now();\n        var value = this.sliceRange(startPosition.offset, endPosition.offset);\n        return {\n            value: value,\n            startPosition: startPosition,\n            endPosition: endPosition\n        };\n    };\n    /**\n     * Slice text form the range.\n     * @param {number} start\n     * @param {number} end\n     * @returns {string}\n     */\n    SourceCode.prototype.sliceRange = function (start, end) {\n        return this.textCharacters.slice(start, end).join(\"\");\n    };\n    return SourceCode;\n}());\nexports.SourceCode = SourceCode;\n"},"sourceMaps":{"js":{"version":3,"file":"SourceCode.js","sourceRoot":"","sources":["../../src/parser/SourceCode.ts"],"names":[],"mappings":"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","sourcesContent":["import { TxtNode, TxtParentNode } from \"@textlint/ast-node-types\";\nimport { AbstractParser } from \"./AbstractParser\";\n\nconst StructureSource = require(\"structured-source\");\n\nexport class SourceCode {\n    private index: number = 0;\n    private source: any;\n    private textCharacters: string[];\n    private sourceNode?: TxtParentNode;\n    private contexts: string[] = [];\n    private contextRanges: [number, number][] = [];\n    private firstChildPadding: number;\n    private startOffset: number;\n\n    constructor(input: string | TxtParentNode) {\n        if (typeof input === \"string\") {\n            this.textCharacters = input.split(\"\");\n            this.source = new StructureSource(input);\n            this.startOffset = 0;\n            this.firstChildPadding = 0;\n        } else {\n            this.sourceNode = input;\n            // When pass AST, fist node may be >=\n            // Preserve it as `startOffset`\n            this.startOffset = this.sourceNode.range[0];\n            // start index is startOffset\n            this.index = this.startOffset;\n            // before line count of Paragraph node\n            const lineBreaks = Array.from(new Array(this.sourceNode.loc.start.line - 1)).fill(\"\\n\");\n            // filled with dummy text\n            const offset = Array.from(new Array(this.startOffset - lineBreaks.length)).fill(\"∯\");\n            this.textCharacters = offset.concat(lineBreaks, input.raw.split(\"\"));\n            this.source = new StructureSource(this.textCharacters.join(\"\"));\n            if (this.sourceNode.children[0]) {\n                // Header Node's children does not start with index 0\n                // Example: # Header\n                // It firstChildPadding is `2`\n                this.firstChildPadding = this.sourceNode.children[0].range[0] - this.startOffset;\n            } else {\n                this.firstChildPadding = 0;\n            }\n        }\n    }\n\n    markContextRange(range: [number, number]) {\n        this.contextRanges.push(range);\n    }\n\n    isInContextRange() {\n        const offset = this.offset;\n        return this.contextRanges.some(range => {\n            return range[0] <= offset && offset < range[1];\n        });\n    }\n\n    enterContext(context: string) {\n        this.contexts.push(context);\n    }\n\n    isInContext(context?: string) {\n        if (!context) {\n            return this.contexts.length > 0;\n        }\n        return this.contexts.some(targetContext => targetContext === context);\n    }\n\n    leaveContext(context: string) {\n        const index = this.contexts.lastIndexOf(context);\n        if (index !== -1) {\n            this.contexts.splice(index, 1);\n        }\n    }\n\n    /**\n     * Return current offset value\n     * @returns {number}\n     */\n    get offset() {\n        return this.index + this.firstChildPadding;\n    }\n\n    /**\n     * Return current position object.\n     * It includes line, column, offset.\n     */\n    now() {\n        const indexWithChildrenOffset = this.offset;\n        const position = this.source.indexToPosition(indexWithChildrenOffset);\n        return {\n            line: position.line as number,\n            column: position.column as number,\n            offset: indexWithChildrenOffset\n        };\n    }\n\n    /**\n     * Return true, no more read char\n     */\n    get hasEnd() {\n        return this.read() === false;\n    }\n\n    /**\n     * read char\n     * if can not read, return empty string\n     * @returns {string}\n     */\n    read(over: number = 0) {\n        const index = this.offset + over;\n        if (index < this.startOffset) {\n            return false;\n        }\n        if (0 <= index && index < this.textCharacters.length) {\n            return this.textCharacters[index];\n        }\n        return false;\n    }\n\n    /**\n     * read node\n     * if can not read, return empty string\n     * @returns {node}\n     */\n    readNode(over: number = 0) {\n        if (!this.sourceNode) {\n            return false;\n        }\n        const index = this.offset + over;\n        if (index < this.startOffset) {\n            return false;\n        }\n        const matchNodeList = this.sourceNode.children.filter(node => {\n            // <p>[node]</p>\n            //         ^\n            //        range[1]\n            // `< range[1]` prevent infinity loop\n            // https://github.com/azu/sentence-splitter/issues/9\n            return node.range[0] <= index && index < node.range[1];\n        });\n        if (matchNodeList.length > 0) {\n            // last match\n            // because, range is overlap two nodes\n            return matchNodeList[matchNodeList.length - 1];\n        }\n        return false;\n    }\n\n    /**\n     * Increment current index\n     */\n    peek() {\n        this.index += 1;\n    }\n\n    /**\n     * Increment node range\n     */\n    peekNode(node: TxtNode) {\n        this.index += node.range[1] - node.range[0];\n    }\n\n    /**\n     * Seek and Peek\n     */\n    seekNext(\n        parser: AbstractParser\n    ): {\n        value: string;\n        startPosition: {\n            line: number;\n            column: number;\n            offset: number;\n        };\n        endPosition: {\n            line: number;\n            column: number;\n            offset: number;\n        };\n    } {\n        const startPosition = this.now();\n        parser.seek(this);\n        const endPosition = this.now();\n        const value = this.sliceRange(startPosition.offset, endPosition.offset);\n        return {\n            value,\n            startPosition,\n            endPosition\n        };\n    }\n\n    /**\n     * Slice text form the range.\n     * @param {number} start\n     * @param {number} end\n     * @returns {string}\n     */\n    sliceRange(start: number, end: number): string {\n        return this.textCharacters.slice(start, end).join(\"\");\n    }\n}\n"]}},"error":null,"hash":"de565f3d66d4006b261bd275a3cbf5a9","cacheData":{"env":{}}}