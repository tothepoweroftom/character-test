{"id":"node_modules/sentence-splitter/lib/parser/AnyValueParser.js","dependencies":[{"name":"/Users/tom/Documents/GitHub/fabricating-alternatives-004/node_modules/sentence-splitter/lib/parser/AnyValueParser.js.map","includedInParent":true,"mtime":499162500000},{"name":"/Users/tom/Documents/GitHub/fabricating-alternatives-004/node_modules/sentence-splitter/src/parser/AnyValueParser.ts","includedInParent":true,"mtime":499162500000},{"name":"/Users/tom/Documents/GitHub/fabricating-alternatives-004/package.json","includedInParent":true,"mtime":1563189193141},{"name":"/Users/tom/Documents/GitHub/fabricating-alternatives-004/node_modules/sentence-splitter/package.json","includedInParent":true,"mtime":1563189192585}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Any value without `parsers`\n */\nvar AnyValueParser = /** @class */ (function () {\n    /**\n     * Eat any value without `parsers.test`\n     */\n    function AnyValueParser(options) {\n        this.parsers = options.parsers;\n        this.markers = options.markers;\n    }\n    AnyValueParser.prototype.test = function (sourceCode) {\n        if (sourceCode.hasEnd) {\n            return false;\n        }\n        return this.parsers.every(function (parser) { return !parser.test(sourceCode); });\n    };\n    AnyValueParser.prototype.seek = function (sourceCode) {\n        var currentNode = sourceCode.readNode();\n        if (!currentNode) {\n            // Text mode\n            while (this.test(sourceCode)) {\n                this.markers.forEach(function (marker) { return marker.mark(sourceCode); });\n                sourceCode.peek();\n            }\n            return;\n        }\n        // node - should not over next node\n        var isInCurrentNode = function () {\n            var currentOffset = sourceCode.offset;\n            return currentNode.range[0] <= currentOffset && currentOffset < currentNode.range[1];\n        };\n        while (isInCurrentNode() && this.test(sourceCode)) {\n            this.markers.forEach(function (marker) { return marker.mark(sourceCode); });\n            sourceCode.peek();\n        }\n    };\n    return AnyValueParser;\n}());\nexports.AnyValueParser = AnyValueParser;\n"},"sourceMaps":{"js":{"version":3,"file":"AnyValueParser.js","sourceRoot":"","sources":["../../src/parser/AnyValueParser.ts"],"names":[],"mappings":";;AASA;;GAEG;AACH;IAII;;OAEG;IACH,wBAAY,OAA8B;QACtC,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC,OAAO,CAAC;QAC/B,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC,OAAO,CAAC;IACnC,CAAC;IAED,6BAAI,GAAJ,UAAK,UAAsB;QACvB,IAAI,UAAU,CAAC,MAAM,EAAE;YACnB,OAAO,KAAK,CAAC;SAChB;QACD,OAAO,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,UAAA,MAAM,IAAI,OAAA,CAAC,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,EAAxB,CAAwB,CAAC,CAAC;IAClE,CAAC;IAED,6BAAI,GAAJ,UAAK,UAAsB;QACvB,IAAM,WAAW,GAAG,UAAU,CAAC,QAAQ,EAAE,CAAC;QAC1C,IAAI,CAAC,WAAW,EAAE;YACd,YAAY;YACZ,OAAO,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,EAAE;gBAC1B,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,UAAA,MAAM,IAAI,OAAA,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,EAAvB,CAAuB,CAAC,CAAC;gBACxD,UAAU,CAAC,IAAI,EAAE,CAAC;aACrB;YACD,OAAO;SACV;QACD,mCAAmC;QACnC,IAAM,eAAe,GAAG;YACpB,IAAM,aAAa,GAAG,UAAU,CAAC,MAAM,CAAC;YACxC,OAAO,WAAW,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,aAAa,IAAI,aAAa,GAAG,WAAW,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;QACzF,CAAC,CAAC;QACF,OAAO,eAAe,EAAE,IAAI,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,EAAE;YAC/C,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,UAAA,MAAM,IAAI,OAAA,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,EAAvB,CAAuB,CAAC,CAAC;YACxD,UAAU,CAAC,IAAI,EAAE,CAAC;SACrB;IACL,CAAC;IACL,qBAAC;AAAD,CAAC,AAvCD,IAuCC;AAvCY,wCAAc","sourcesContent":["import { SourceCode } from \"./SourceCode\";\nimport { AbstractParser } from \"./AbstractParser\";\nimport { AbstractMarker } from \"./AbstractMarker\";\n\nexport interface AnyValueParserOptions {\n    parsers: AbstractParser[];\n    markers: AbstractMarker[];\n}\n\n/**\n * Any value without `parsers`\n */\nexport class AnyValueParser implements AbstractParser {\n    private parsers: AbstractParser[];\n    private markers: AbstractMarker[];\n\n    /**\n     * Eat any value without `parsers.test`\n     */\n    constructor(options: AnyValueParserOptions) {\n        this.parsers = options.parsers;\n        this.markers = options.markers;\n    }\n\n    test(sourceCode: SourceCode) {\n        if (sourceCode.hasEnd) {\n            return false;\n        }\n        return this.parsers.every(parser => !parser.test(sourceCode));\n    }\n\n    seek(sourceCode: SourceCode) {\n        const currentNode = sourceCode.readNode();\n        if (!currentNode) {\n            // Text mode\n            while (this.test(sourceCode)) {\n                this.markers.forEach(marker => marker.mark(sourceCode));\n                sourceCode.peek();\n            }\n            return;\n        }\n        // node - should not over next node\n        const isInCurrentNode = () => {\n            const currentOffset = sourceCode.offset;\n            return currentNode.range[0] <= currentOffset && currentOffset < currentNode.range[1];\n        };\n        while (isInCurrentNode() && this.test(sourceCode)) {\n            this.markers.forEach(marker => marker.mark(sourceCode));\n            sourceCode.peek();\n        }\n    }\n}\n"]}},"error":null,"hash":"d73a2fe5c74f80c10a4d4479a8806e35","cacheData":{"env":{}}}