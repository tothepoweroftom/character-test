{"id":"node_modules/sentence-splitter/lib/sentence-splitter.js","dependencies":[{"name":"/Users/tom/Documents/GitHub/fabricating-alternatives-004/node_modules/sentence-splitter/lib/sentence-splitter.js.map","includedInParent":true,"mtime":499162500000},{"name":"/Users/tom/Documents/GitHub/fabricating-alternatives-004/node_modules/sentence-splitter/src/sentence-splitter.ts","includedInParent":true,"mtime":499162500000},{"name":"/Users/tom/Documents/GitHub/fabricating-alternatives-004/package.json","includedInParent":true,"mtime":1563189193141},{"name":"/Users/tom/Documents/GitHub/fabricating-alternatives-004/node_modules/sentence-splitter/package.json","includedInParent":true,"mtime":1563189192585},{"name":"@textlint/ast-node-types","loc":{"line":12,"column":31},"parent":"/Users/tom/Documents/GitHub/fabricating-alternatives-004/node_modules/sentence-splitter/lib/sentence-splitter.js","resolved":"/Users/tom/Documents/GitHub/fabricating-alternatives-004/node_modules/@textlint/ast-node-types/lib/index.js"},{"name":"./parser/SourceCode","loc":{"line":13,"column":27},"parent":"/Users/tom/Documents/GitHub/fabricating-alternatives-004/node_modules/sentence-splitter/lib/sentence-splitter.js","resolved":"/Users/tom/Documents/GitHub/fabricating-alternatives-004/node_modules/sentence-splitter/lib/parser/SourceCode.js"},{"name":"./parser/NewLineParser","loc":{"line":14,"column":30},"parent":"/Users/tom/Documents/GitHub/fabricating-alternatives-004/node_modules/sentence-splitter/lib/sentence-splitter.js","resolved":"/Users/tom/Documents/GitHub/fabricating-alternatives-004/node_modules/sentence-splitter/lib/parser/NewLineParser.js"},{"name":"./parser/SpaceParser","loc":{"line":15,"column":28},"parent":"/Users/tom/Documents/GitHub/fabricating-alternatives-004/node_modules/sentence-splitter/lib/sentence-splitter.js","resolved":"/Users/tom/Documents/GitHub/fabricating-alternatives-004/node_modules/sentence-splitter/lib/parser/SpaceParser.js"},{"name":"./parser/SeparatorParser","loc":{"line":16,"column":32},"parent":"/Users/tom/Documents/GitHub/fabricating-alternatives-004/node_modules/sentence-splitter/lib/sentence-splitter.js","resolved":"/Users/tom/Documents/GitHub/fabricating-alternatives-004/node_modules/sentence-splitter/lib/parser/SeparatorParser.js"},{"name":"./parser/AnyValueParser","loc":{"line":17,"column":31},"parent":"/Users/tom/Documents/GitHub/fabricating-alternatives-004/node_modules/sentence-splitter/lib/sentence-splitter.js","resolved":"/Users/tom/Documents/GitHub/fabricating-alternatives-004/node_modules/sentence-splitter/lib/parser/AnyValueParser.js"},{"name":"./parser/AbbrMarker","loc":{"line":18,"column":27},"parent":"/Users/tom/Documents/GitHub/fabricating-alternatives-004/node_modules/sentence-splitter/lib/sentence-splitter.js","resolved":"/Users/tom/Documents/GitHub/fabricating-alternatives-004/node_modules/sentence-splitter/lib/parser/AbbrMarker.js"},{"name":"./parser/PairMaker","loc":{"line":19,"column":26},"parent":"/Users/tom/Documents/GitHub/fabricating-alternatives-004/node_modules/sentence-splitter/lib/sentence-splitter.js","resolved":"/Users/tom/Documents/GitHub/fabricating-alternatives-004/node_modules/sentence-splitter/lib/parser/PairMaker.js"},{"name":"./logger","loc":{"line":20,"column":23},"parent":"/Users/tom/Documents/GitHub/fabricating-alternatives-004/node_modules/sentence-splitter/lib/sentence-splitter.js","resolved":"/Users/tom/Documents/GitHub/fabricating-alternatives-004/node_modules/sentence-splitter/lib/logger.js"}],"generated":{"js":"// LICENSE : MIT\n\"use strict\";\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ast_node_types_1 = require(\"@textlint/ast-node-types\");\nvar SourceCode_1 = require(\"./parser/SourceCode\");\nvar NewLineParser_1 = require(\"./parser/NewLineParser\");\nvar SpaceParser_1 = require(\"./parser/SpaceParser\");\nvar SeparatorParser_1 = require(\"./parser/SeparatorParser\");\nvar AnyValueParser_1 = require(\"./parser/AnyValueParser\");\nvar AbbrMarker_1 = require(\"./parser/AbbrMarker\");\nvar PairMaker_1 = require(\"./parser/PairMaker\");\nvar logger_1 = require(\"./logger\");\nexports.Syntax = {\n    WhiteSpace: \"WhiteSpace\",\n    Punctuation: \"Punctuation\",\n    Sentence: \"Sentence\",\n    Str: \"Str\"\n};\nvar SplitParser = /** @class */ (function () {\n    function SplitParser(text) {\n        this.nodeList = [];\n        this.results = [];\n        this.source = new SourceCode_1.SourceCode(text);\n    }\n    Object.defineProperty(SplitParser.prototype, \"current\", {\n        get: function () {\n            return this.nodeList[this.nodeList.length - 1];\n        },\n        enumerable: true,\n        configurable: true\n    });\n    SplitParser.prototype.pushNodeToCurrent = function (node) {\n        var current = this.current;\n        if (current) {\n            current.children.push(node);\n        }\n        else {\n            // Under the root\n            this.results.push(node);\n        }\n    };\n    // open with ParentNode\n    SplitParser.prototype.open = function (parentNode) {\n        this.nodeList.push(parentNode);\n    };\n    SplitParser.prototype.isOpened = function () {\n        return this.nodeList.length > 0;\n    };\n    SplitParser.prototype.nextLine = function (parser) {\n        var _a = this.source.seekNext(parser), value = _a.value, startPosition = _a.startPosition, endPosition = _a.endPosition;\n        this.pushNodeToCurrent(createWhiteSpaceNode(value, startPosition, endPosition));\n        return endPosition;\n    };\n    SplitParser.prototype.nextSpace = function (parser) {\n        var _a = this.source.seekNext(parser), value = _a.value, startPosition = _a.startPosition, endPosition = _a.endPosition;\n        this.pushNodeToCurrent(createNode(\"WhiteSpace\", value, startPosition, endPosition));\n    };\n    SplitParser.prototype.nextValue = function (parser) {\n        var _a = this.source.seekNext(parser), value = _a.value, startPosition = _a.startPosition, endPosition = _a.endPosition;\n        this.pushNodeToCurrent(createTextNode(value, startPosition, endPosition));\n    };\n    // close current Node and remove it from list\n    SplitParser.prototype.close = function (parser) {\n        var _a = this.source.seekNext(parser), value = _a.value, startPosition = _a.startPosition, endPosition = _a.endPosition;\n        if (startPosition.offset !== endPosition.offset) {\n            this.pushNodeToCurrent(createPunctuationNode(value, startPosition, endPosition));\n        }\n        var currentNode = this.nodeList.pop();\n        if (!currentNode) {\n            return;\n        }\n        if (currentNode.children.length === 0) {\n            return;\n        }\n        var firstChildNode = currentNode.children[0];\n        var endNow = this.source.now();\n        currentNode.loc = {\n            start: firstChildNode.loc.start,\n            end: nowToLoc(endNow)\n        };\n        var rawValue = this.source.sliceRange(firstChildNode.range[0], endNow.offset);\n        currentNode.range = [firstChildNode.range[0], endNow.offset];\n        currentNode.raw = rawValue;\n        this.results.push(currentNode);\n    };\n    SplitParser.prototype.toList = function () {\n        return this.results;\n    };\n    return SplitParser;\n}());\nexports.SplitParser = SplitParser;\n/**\n * split `text` into Sentence nodes\n */\nfunction split(text) {\n    var newLine = new NewLineParser_1.NewLineParser();\n    var space = new SpaceParser_1.SpaceParser();\n    var separator = new SeparatorParser_1.SeparatorParser();\n    var abbrMarker = new AbbrMarker_1.AbbrMarker();\n    var pairMaker = new PairMaker_1.PairMaker();\n    // anyValueParser has multiple parser and markers.\n    // anyValueParse eat any value if it reach to other value.\n    var anyValueParser = new AnyValueParser_1.AnyValueParser({\n        parsers: [newLine, separator],\n        markers: [abbrMarker, pairMaker]\n    });\n    var splitParser = new SplitParser(text);\n    var sourceCode = splitParser.source;\n    while (!sourceCode.hasEnd) {\n        if (newLine.test(sourceCode)) {\n            splitParser.nextLine(newLine);\n        }\n        else if (space.test(sourceCode)) {\n            // Add WhiteSpace\n            splitParser.nextSpace(space);\n        }\n        else if (separator.test(sourceCode)) {\n            splitParser.close(separator);\n        }\n        else {\n            if (!splitParser.isOpened()) {\n                splitParser.open(createEmptySentenceNode());\n            }\n            splitParser.nextValue(anyValueParser);\n        }\n    }\n    splitParser.close(space);\n    return splitParser.toList();\n}\nexports.split = split;\n/**\n * Convert Paragraph Node to Paragraph node that convert children to Sentence node\n * This Node is based on TxtAST.\n * See https://github.com/textlint/textlint/blob/master/docs/txtnode.md\n */\nfunction splitAST(paragraphNode) {\n    var newLine = new NewLineParser_1.NewLineParser();\n    var space = new SpaceParser_1.SpaceParser();\n    var separator = new SeparatorParser_1.SeparatorParser();\n    var abbrMarker = new AbbrMarker_1.AbbrMarker();\n    var pairMaker = new PairMaker_1.PairMaker();\n    var anyValue = new AnyValueParser_1.AnyValueParser({\n        parsers: [newLine, separator],\n        markers: [abbrMarker, pairMaker]\n    });\n    var splitParser = new SplitParser(paragraphNode);\n    var sourceCode = splitParser.source;\n    while (!sourceCode.hasEnd) {\n        var currentNode = sourceCode.readNode();\n        if (!currentNode) {\n            break;\n        }\n        if (currentNode.type === ast_node_types_1.ASTNodeTypes.Str) {\n            if (space.test(sourceCode)) {\n                logger_1.debugLog(\"space\");\n                splitParser.nextSpace(space);\n            }\n            else if (separator.test(sourceCode)) {\n                logger_1.debugLog(\"separator\");\n                splitParser.close(separator);\n            }\n            else if (newLine.test(sourceCode)) {\n                logger_1.debugLog(\"newline\");\n                splitParser.nextLine(newLine);\n            }\n            else {\n                if (!splitParser.isOpened()) {\n                    logger_1.debugLog(\"open -> createEmptySentenceNode()\");\n                    splitParser.open(createEmptySentenceNode());\n                }\n                splitParser.nextValue(anyValue);\n            }\n        }\n        else {\n            if (!splitParser.isOpened()) {\n                splitParser.open(createEmptySentenceNode());\n            }\n            splitParser.pushNodeToCurrent(currentNode);\n            sourceCode.peekNode(currentNode);\n        }\n    }\n    // It follow some text that is not ended with period.\n    // TODO: space is correct?\n    splitParser.close(space);\n    return __assign({}, paragraphNode, { children: splitParser.toList() });\n}\nexports.splitAST = splitAST;\n/**\n * WhiteSpace is space or linebreak\n */\nfunction createWhiteSpaceNode(text, startPosition, endPosition) {\n    return createNode(\"WhiteSpace\", text, startPosition, endPosition);\n}\nexports.createWhiteSpaceNode = createWhiteSpaceNode;\nfunction createPunctuationNode(text, startPosition, endPosition) {\n    return createNode(\"Punctuation\", text, startPosition, endPosition);\n}\nexports.createPunctuationNode = createPunctuationNode;\nfunction createTextNode(text, startPosition, endPosition) {\n    return createNode(\"Str\", text, startPosition, endPosition);\n}\nexports.createTextNode = createTextNode;\nfunction createEmptySentenceNode() {\n    return {\n        type: \"Sentence\",\n        raw: \"\",\n        loc: {\n            start: { column: NaN, line: NaN },\n            end: { column: NaN, line: NaN }\n        },\n        range: [NaN, NaN],\n        children: []\n    };\n}\nexports.createEmptySentenceNode = createEmptySentenceNode;\nfunction createNode(type, text, startPosition, endPosition) {\n    return {\n        type: type,\n        raw: text,\n        value: text,\n        loc: {\n            start: nowToLoc(startPosition),\n            end: nowToLoc(endPosition)\n        },\n        range: [startPosition.offset, endPosition.offset]\n    };\n}\nexports.createNode = createNode;\nfunction nowToLoc(now) {\n    return {\n        line: now.line,\n        column: now.column\n    };\n}\n"},"sourceMaps":{"js":{"version":3,"file":"sentence-splitter.js","sourceRoot":"","sources":["../src/sentence-splitter.ts"],"names":[],"mappings":"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","sourcesContent":["// LICENSE : MIT\n\"use strict\";\nimport { TxtNode, TxtParentNode, ASTNodeTypes, TxtTextNode } from \"@textlint/ast-node-types\";\nimport { SourceCode } from \"./parser/SourceCode\";\nimport { AbstractParser } from \"./parser/AbstractParser\";\nimport { NewLineParser } from \"./parser/NewLineParser\";\nimport { SpaceParser } from \"./parser/SpaceParser\";\nimport { SeparatorParser } from \"./parser/SeparatorParser\";\nimport { AnyValueParser } from \"./parser/AnyValueParser\";\nimport { AbbrMarker } from \"./parser/AbbrMarker\";\nimport { PairMaker } from \"./parser/PairMaker\";\nimport { debugLog } from \"./logger\";\n\nexport const Syntax = {\n    WhiteSpace: \"WhiteSpace\",\n    Punctuation: \"Punctuation\",\n    Sentence: \"Sentence\",\n    Str: \"Str\"\n};\n\nexport interface ToTypeNode<T extends string> extends TxtTextNode {\n    readonly type: T;\n}\n\nexport interface WhiteSpaceNode extends TxtTextNode {\n    readonly type: \"WhiteSpace\";\n}\n\nexport interface PunctuationNode extends TxtTextNode {\n    readonly type: \"Punctuation\";\n}\n\nexport interface StrNode extends TxtTextNode {\n    readonly type: \"Str\";\n}\n\nexport interface SentenceNode extends TxtParentNode {\n    readonly type: \"Sentence\";\n}\n\nexport class SplitParser {\n    private nodeList: TxtParentNode[] = [];\n    private results: (TxtParentNode | TxtNode)[] = [];\n    public source: SourceCode;\n\n    constructor(text: string | TxtParentNode) {\n        this.source = new SourceCode(text);\n    }\n\n    get current(): TxtParentNode | undefined {\n        return this.nodeList[this.nodeList.length - 1];\n    }\n\n    pushNodeToCurrent(node: TxtNode) {\n        const current = this.current;\n        if (current) {\n            current.children.push(node);\n        } else {\n            // Under the root\n            this.results.push(node);\n        }\n    }\n\n    // open with ParentNode\n    open(parentNode: TxtParentNode) {\n        this.nodeList.push(parentNode);\n    }\n\n    isOpened() {\n        return this.nodeList.length > 0;\n    }\n\n    nextLine(parser: AbstractParser) {\n        const { value, startPosition, endPosition } = this.source.seekNext(parser);\n        this.pushNodeToCurrent(createWhiteSpaceNode(value, startPosition, endPosition));\n        return endPosition;\n    }\n\n    nextSpace(parser: AbstractParser) {\n        const { value, startPosition, endPosition } = this.source.seekNext(parser);\n        this.pushNodeToCurrent(createNode(\"WhiteSpace\", value, startPosition, endPosition));\n    }\n\n    nextValue(parser: AbstractParser) {\n        const { value, startPosition, endPosition } = this.source.seekNext(parser);\n        this.pushNodeToCurrent(createTextNode(value, startPosition, endPosition));\n    }\n\n    // close current Node and remove it from list\n    close(parser: AbstractParser) {\n        const { value, startPosition, endPosition } = this.source.seekNext(parser);\n        if (startPosition.offset !== endPosition.offset) {\n            this.pushNodeToCurrent(createPunctuationNode(value, startPosition, endPosition));\n        }\n        const currentNode = this.nodeList.pop();\n        if (!currentNode) {\n            return;\n        }\n        if (currentNode.children.length === 0) {\n            return;\n        }\n        const firstChildNode: TxtNode = currentNode.children[0];\n        const endNow = this.source.now();\n        currentNode.loc = {\n            start: firstChildNode.loc.start,\n            end: nowToLoc(endNow)\n        };\n        const rawValue = this.source.sliceRange(firstChildNode.range[0], endNow.offset);\n        currentNode.range = [firstChildNode.range[0], endNow.offset];\n        currentNode.raw = rawValue;\n        this.results.push(currentNode);\n    }\n\n    toList() {\n        return this.results;\n    }\n}\n\n/**\n * split `text` into Sentence nodes\n */\nexport function split(text: string): (TxtParentNode | TxtNode)[] {\n    const newLine = new NewLineParser();\n    const space = new SpaceParser();\n    const separator = new SeparatorParser();\n    const abbrMarker = new AbbrMarker();\n    const pairMaker = new PairMaker();\n    // anyValueParser has multiple parser and markers.\n    // anyValueParse eat any value if it reach to other value.\n    const anyValueParser = new AnyValueParser({\n        parsers: [newLine, separator],\n        markers: [abbrMarker, pairMaker]\n    });\n    const splitParser = new SplitParser(text);\n    const sourceCode = splitParser.source;\n    while (!sourceCode.hasEnd) {\n        if (newLine.test(sourceCode)) {\n            splitParser.nextLine(newLine);\n        } else if (space.test(sourceCode)) {\n            // Add WhiteSpace\n            splitParser.nextSpace(space);\n        } else if (separator.test(sourceCode)) {\n            splitParser.close(separator);\n        } else {\n            if (!splitParser.isOpened()) {\n                splitParser.open(createEmptySentenceNode());\n            }\n            splitParser.nextValue(anyValueParser);\n        }\n    }\n    splitParser.close(space);\n    return splitParser.toList();\n}\n\n/**\n * Convert Paragraph Node to Paragraph node that convert children to Sentence node\n * This Node is based on TxtAST.\n * See https://github.com/textlint/textlint/blob/master/docs/txtnode.md\n */\nexport function splitAST(paragraphNode: TxtParentNode): TxtParentNode {\n    const newLine = new NewLineParser();\n    const space = new SpaceParser();\n    const separator = new SeparatorParser();\n    const abbrMarker = new AbbrMarker();\n    const pairMaker = new PairMaker();\n    const anyValue = new AnyValueParser({\n        parsers: [newLine, separator],\n        markers: [abbrMarker, pairMaker]\n    });\n    const splitParser = new SplitParser(paragraphNode);\n    const sourceCode = splitParser.source;\n    while (!sourceCode.hasEnd) {\n        const currentNode = sourceCode.readNode();\n        if (!currentNode) {\n            break;\n        }\n        if (currentNode.type === ASTNodeTypes.Str) {\n            if (space.test(sourceCode)) {\n                debugLog(\"space\");\n                splitParser.nextSpace(space);\n            } else if (separator.test(sourceCode)) {\n                debugLog(\"separator\");\n                splitParser.close(separator);\n            } else if (newLine.test(sourceCode)) {\n                debugLog(\"newline\");\n                splitParser.nextLine(newLine);\n            } else {\n                if (!splitParser.isOpened()) {\n                    debugLog(\"open -> createEmptySentenceNode()\");\n                    splitParser.open(createEmptySentenceNode());\n                }\n                splitParser.nextValue(anyValue);\n            }\n        } else {\n            if (!splitParser.isOpened()) {\n                splitParser.open(createEmptySentenceNode());\n            }\n            splitParser.pushNodeToCurrent(currentNode);\n            sourceCode.peekNode(currentNode);\n        }\n    }\n\n    // It follow some text that is not ended with period.\n    // TODO: space is correct?\n    splitParser.close(space);\n    return {\n        ...paragraphNode,\n        children: splitParser.toList()\n    };\n}\n\n/**\n * WhiteSpace is space or linebreak\n */\nexport function createWhiteSpaceNode(\n    text: string,\n    startPosition: {\n        line: number;\n        column: number;\n        offset: number;\n    },\n    endPosition: {\n        line: number;\n        column: number;\n        offset: number;\n    }\n) {\n    return createNode(\"WhiteSpace\", text, startPosition, endPosition);\n}\n\nexport function createPunctuationNode(\n    text: string,\n    startPosition: {\n        line: number;\n        column: number;\n        offset: number;\n    },\n    endPosition: {\n        line: number;\n        column: number;\n        offset: number;\n    }\n): PunctuationNode {\n    return createNode(\"Punctuation\", text, startPosition, endPosition);\n}\n\nexport function createTextNode(\n    text: string,\n    startPosition: {\n        line: number;\n        column: number;\n        offset: number;\n    },\n    endPosition: {\n        line: number;\n        column: number;\n        offset: number;\n    }\n): StrNode {\n    return createNode(\"Str\", text, startPosition, endPosition);\n}\n\nexport function createEmptySentenceNode(): SentenceNode {\n    return {\n        type: \"Sentence\",\n        raw: \"\",\n        loc: {\n            start: { column: NaN, line: NaN },\n            end: { column: NaN, line: NaN }\n        },\n        range: [NaN, NaN],\n        children: []\n    };\n}\n\nexport function createNode<T extends string>(\n    type: T,\n    text: string,\n    startPosition: {\n        line: number;\n        column: number;\n        offset: number;\n    },\n    endPosition: {\n        line: number;\n        column: number;\n        offset: number;\n    }\n): ToTypeNode<T> {\n    return {\n        type: type,\n        raw: text,\n        value: text,\n        loc: {\n            start: nowToLoc(startPosition),\n            end: nowToLoc(endPosition)\n        },\n        range: [startPosition.offset, endPosition.offset]\n    };\n}\n\nfunction nowToLoc(now: { line: number; column: number; offset: number }) {\n    return {\n        line: now.line,\n        column: now.column\n    };\n}\n"]}},"error":null,"hash":"b25c87ebe8c38a8142ab8df3162350d4","cacheData":{"env":{}}}